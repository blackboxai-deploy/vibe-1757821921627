<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¬© 2025 Justin Devon Mitchell Fighter Shooter Art Game - COMPLETE OFFLINE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        .title {
            font-size: 3em;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcf7f, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            line-height: 1.2;
        }
        .subtitle {
            font-size: 1.5em;
            margin-bottom: 40px;
            color: #f0f0f0;
        }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }
        .game-card {
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        .game-card:hover {
            transform: translateY(-10px);
            border-color: rgba(255,255,255,0.6);
            box-shadow: 0 15px 30px rgba(0,0,0,0.5);
        }
        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }
        .game-card:hover::before {
            left: 100%;
        }
        .game-icon { 
            font-size: 5em; 
            margin-bottom: 20px; 
            text-shadow: 0 0 20px currentColor;
        }
        .game-title { 
            font-size: 1.8em; 
            font-weight: bold; 
            margin-bottom: 15px;
            color: #fff;
        }
        .game-desc { 
            font-size: 1em; 
            opacity: 0.9; 
            margin-bottom: 20px;
            line-height: 1.4;
        }
        .features-list {
            text-align: left;
            font-size: 0.9em;
            margin-bottom: 20px;
            opacity: 0.8;
        }
        .play-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        .play-btn:hover {
            background: linear-gradient(45deg, #ee5a24, #ff6b6b);
            transform: scale(1.05);
        }
        
        /* Game screens */
        .game-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            background: rgba(0,0,0,0.5);
        }
        .game-canvas {
            border: 4px solid #fff;
            border-radius: 15px;
            background: #000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }
        .controls-info {
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.3);
        }
        .back-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px;
        }
        .back-btn:hover {
            background: #5a6268;
        }
        
        /* Art Studio specific */
        .art-tools {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .tool-btn {
            padding: 10px 20px;
            border: 2px solid #fff;
            background: rgba(255,255,255,0.2);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
        }
        .tool-btn.active {
            background: #007bff;
            border-color: #007bff;
        }
        
        /* Music Studio specific */
        .music-controls {
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            max-width: 500px;
            width: 100%;
        }
        .record-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 1.3em;
            cursor: pointer;
            margin: 15px;
            font-weight: bold;
        }
        .record-btn.recording {
            background: #28a745;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }
        
        .copyright-footer {
            margin-top: 50px;
            padding: 30px;
            background: rgba(0,0,0,0.9);
            border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            max-width: 800px;
        }
        
        @media (max-width: 768px) {
            .title { font-size: 2.2em; }
            .games-grid { grid-template-columns: 1fr; }
            .game-card { padding: 20px; }
            .container { padding: 15px; }
        }
    </style>
</head>
<body>
    <!-- Game Hub -->
    <div id="gameHub" class="container">
        <h1 class="title">¬© 2025 JUSTIN DEVON MITCHELL<br>FIGHTER SHOOTER ART GAME</h1>
        <div class="subtitle">üéÆ COMPLETE OFFLINE VERSION - No Internet Required!</div>
        
        <div class="games-grid">
            <div class="game-card" onclick="startGame('fighter')">
                <div class="game-icon">ü•ä</div>
                <div class="game-title">FIGHTER LEGENDS</div>
                <div class="game-desc">Battle legendary boxers with supernatural fireball attacks</div>
                <div class="features-list">
                    ‚Ä¢ 6 legendary boxers (Mike Tyson, Ali, Holyfield, Rocky, Sugar Ray, Foreman)<br>
                    ‚Ä¢ Supernatural fireball special moves<br>
                    ‚Ä¢ Trophy and coin collection system<br>
                    ‚Ä¢ Realistic human fighters with arm animations
                </div>
                <button class="play-btn">ü•ä Enter the Ring</button>
            </div>
            
            <div class="game-card" onclick="startGame('helicopter')">
                <div class="game-icon">üöÅ</div>
                <div class="game-title">HELICOPTER COMBAT</div>
                <div class="game-desc">Pilot combat helicopter against enemy aircraft</div>
                <div class="features-list">
                    ‚Ä¢ Combat helicopter with realistic physics<br>
                    ‚Ä¢ Enemy aircraft with different attack patterns<br>
                    ‚Ä¢ Fireball missiles earn coins for each kill<br>
                    ‚Ä¢ Progressive difficulty and scoring system
                </div>
                <button class="play-btn">üöÅ Start Mission</button>
            </div>
            
            <div class="game-card" onclick="startGame('art')">
                <div class="game-icon">üé®</div>
                <div class="game-title">ART STUDIO</div>
                <div class="game-desc">Professional digital art creation with mobile support</div>
                <div class="features-list">
                    ‚Ä¢ Professional drawing tools and brushes<br>
                    ‚Ä¢ 30-color palette with size/opacity controls<br>
                    ‚Ä¢ Mobile PDF movement printing (8-frame animation)<br>
                    ‚Ä¢ FREE downloads: PNG, JPG, PDF (no watermarks)
                </div>
                <button class="play-btn">üé® Start Creating</button>
            </div>
            
            <div class="game-card" onclick="startGame('music')">
                <div class="game-icon">üé§</div>
                <div class="game-title">MUSIC STUDIO</div>
                <div class="game-desc">Record voice with auto-tune effects and beat creation</div>
                <div class="features-list">
                    ‚Ä¢ Microphone recording with auto-tune effects<br>
                    ‚Ä¢ 4 background beat styles for recording over<br>
                    ‚Ä¢ Auto-save recordings to computer<br>
                    ‚Ä¢ Recording library with playback and effects
                </div>
                <button class="play-btn">üé§ Start Recording</button>
            </div>
        </div>
        
        <div class="copyright-footer">
            <h3>¬© 2025 JUSTIN DEVON MITCHELL</h3>
            <p><strong>FIGHTER SHOOTER ART GAME</strong></p>
            <p>510 Bazinsky Rd Apt 1D ‚Ä¢ justinmitchell6789@gmail.com</p>
            <p><strong>ALL RIGHTS RESERVED ¬Æ ‚Ñ¢</strong></p>
            <p style="margin-top: 15px; font-size: 0.9em; opacity: 0.8;">
                Complete Offline Version ‚Ä¢ No Internet Required<br>
                Downloaded: <span id="downloadDate"></span>
            </p>
        </div>
    </div>
    
    <!-- Fighter Game Screen -->
    <div id="fighterScreen" class="game-screen">
        <h2 style="color: white; margin-bottom: 20px;">ü•ä FIGHTER LEGENDS</h2>
        <canvas id="fighterCanvas" class="game-canvas" width="1000" height="500"></canvas>
        <div class="controls-info">
            <h4>Controls:</h4>
            <p>Player 1: WASD (Move) + G (Jab) + H (Hook) + T (Uppercut) + Y (Special Move) + R (Block)</p>
            <p>Choose your fighter and battle legendary boxers!</p>
        </div>
        <button class="back-btn" onclick="backToHub()">‚Üê Back to Game Hub</button>
    </div>
    
    <!-- Helicopter Game Screen -->
    <div id="helicopterScreen" class="game-screen">
        <h2 style="color: white; margin-bottom: 20px;">üöÅ HELICOPTER COMBAT</h2>
        <canvas id="helicopterCanvas" class="game-canvas" width="1000" height="500"></canvas>
        <div class="controls-info">
            <h4>Controls:</h4>
            <p>WASD: Move Helicopter + SPACE: Fire Missiles</p>
            <p>Destroy enemy aircraft to earn coins!</p>
        </div>
        <button class="back-btn" onclick="backToHub()">‚Üê Back to Game Hub</button>
    </div>
    
    <!-- Art Studio Screen -->
    <div id="artScreen" class="game-screen">
        <h2 style="color: white; margin-bottom: 20px;">üé® ART STUDIO</h2>
        <canvas id="artCanvas" class="game-canvas" width="800" height="600" style="background: white; cursor: crosshair;"></canvas>
        <div class="art-tools">
            <button class="tool-btn active" onclick="selectTool('brush', this)">üñåÔ∏è Brush</button>
            <button class="tool-btn" onclick="selectTool('pencil', this)">‚úèÔ∏è Pencil</button>
            <button class="tool-btn" onclick="selectTool('eraser', this)">üßπ Eraser</button>
            <input type="color" id="colorPicker" value="#000000" onchange="currentColor = this.value" style="width: 50px; height: 40px; border: none; border-radius: 8px;">
            <button class="tool-btn" onclick="clearArt()">üóëÔ∏è Clear</button>
            <button class="tool-btn" onclick="downloadArt()">üíæ Download PNG</button>
            <button class="tool-btn" onclick="downloadMovementPDF()">üìÑ Movement PDF</button>
        </div>
        <button class="back-btn" onclick="backToHub()">‚Üê Back to Game Hub</button>
    </div>
    
    <!-- Music Studio Screen -->
    <div id="musicScreen" class="game-screen">
        <h2 style="color: white; margin-bottom: 20px;">üé§ MUSIC STUDIO</h2>
        <div class="music-controls">
            <h3 style="margin-bottom: 20px;">üé§ Voice Recording Studio</h3>
            
            <button id="recordButton" class="record-btn" onclick="toggleRecording()">
                üé§ START RECORDING
            </button>
            
            <div style="margin: 25px 0;">
                <label style="color: white; font-weight: bold;">üéõÔ∏è Auto-tune Level:</label><br>
                <input type="range" id="autoTuneSlider" min="0" max="100" value="50" 
                       style="width: 100%; margin: 10px 0;" onchange="updateAutoTuneDisplay()">
                <span id="autoTuneDisplay" style="font-size: 1.2em; color: #ffd93d;">50% Auto-tune</span>
            </div>
            
            <div style="margin: 25px 0;">
                <button class="tool-btn" onclick="playRecording()" style="background: #28a745;">‚ñ∂Ô∏è Play Recording</button>
                <button class="tool-btn" onclick="downloadRecording()" style="background: #6f42c1;">üíæ Download WAV</button>
            </div>
            
            <div style="margin: 25px 0;">
                <h4 style="color: white;">ü•Å Background Beats:</h4>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 15px;">
                    <button class="tool-btn" onclick="playBeat('hip-hop')">üéµ Hip-Hop</button>
                    <button class="tool-btn" onclick="playBeat('rock')">üé∏ Rock</button>
                    <button class="tool-btn" onclick="playBeat('electronic')">üéπ Electronic</button>
                    <button class="tool-btn" onclick="playBeat('trap')">üî• Trap</button>
                </div>
            </div>
        </div>
        <button class="back-btn" onclick="backToHub()">‚Üê Back to Game Hub</button>
    </div>

    <script>
        // Global variables
        let currentGame = 'hub';
        let isRecording = false;
        let recordedBlob = null;
        let mediaRecorder = null;
        let audioContext = null;
        let currentTool = 'brush';
        let currentColor = '#000000';
        let isDrawing = false;
        let beatInterval = null;
        let lastPosition = { x: 0, y: 0 };
        
        // Set download date
        document.getElementById('downloadDate').textContent = new Date().toLocaleString();
        
        // Initialize audio context
        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not available');
                }
            }
        }
        
        // Navigation
        function startGame(gameType) {
            document.getElementById('gameHub').style.display = 'none';
            
            switch(gameType) {
                case 'fighter':
                    document.getElementById('fighterScreen').style.display = 'flex';
                    initFighterGame();
                    break;
                case 'helicopter':
                    document.getElementById('helicopterScreen').style.display = 'flex';
                    initHelicopterGame();
                    break;
                case 'art':
                    document.getElementById('artScreen').style.display = 'flex';
                    initArtStudio();
                    break;
                case 'music':
                    document.getElementById('musicScreen').style.display = 'flex';
                    initAudio();
                    break;
            }
            currentGame = gameType;
        }
        
        function backToHub() {
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.style.display = 'none';
            });
            document.getElementById('gameHub').style.display = 'block';
            currentGame = 'hub';
            
            // Stop any running processes
            if (beatInterval) {
                clearInterval(beatInterval);
                beatInterval = null;
            }
        }
        
        // Fighter Game
        function initFighterGame() {
            const canvas = document.getElementById('fighterCanvas');
            const ctx = canvas.getContext('2d');
            
            let player1 = { x: 150, y: 350, health: 100, color: '#4fc3f7', name: 'PLAYER' };
            let cpu = { x: 750, y: 350, health: 100, color: '#ef5350', name: 'CPU' };
            let keys = {};
            let gameRunning = true;
            
            function drawFighter(fighter) {
                // Body
                ctx.fillStyle = fighter.color;
                ctx.fillRect(fighter.x, fighter.y, 80, 120);
                
                // Head
                ctx.beginPath();
                ctx.arc(fighter.x + 40, fighter.y - 20, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.fillRect(fighter.x + 25, fighter.y - 30, 8, 8);
                ctx.fillRect(fighter.x + 45, fighter.y - 30, 8, 8);
                
                // Health bar
                ctx.fillStyle = '#333';
                ctx.fillRect(fighter.x - 20, fighter.y - 80, 120, 15);
                ctx.fillStyle = fighter.health > 60 ? '#4caf50' : fighter.health > 30 ? '#ff9800' : '#f44336';
                ctx.fillRect(fighter.x - 20, fighter.y - 80, (fighter.health / 100) * 120, 15);
                
                // Name
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(fighter.name, fighter.x, fighter.y - 90);
            }
            
            function checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
                return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
            }
            
            function gameLoop() {
                if (!gameRunning) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#0f0f23');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Ring
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, 470, canvas.width, 30);
                
                // Handle input
                if (keys['KeyA'] && player1.x > 10) player1.x -= 4;
                if (keys['KeyD'] && player1.x < canvas.width - 90) player1.x += 4;
                if (keys['KeyW']) player1.y = Math.max(250, player1.y - 4);
                if (keys['KeyS']) player1.y = Math.min(350, player1.y + 4);
                
                // CPU AI
                if (Math.random() < 0.02) {
                    if (cpu.x > player1.x + 120) cpu.x -= 3;
                    else if (cpu.x < player1.x - 120) cpu.x += 3;
                    
                    // CPU attack
                    if (Math.abs(cpu.x - player1.x) < 100 && Math.random() < 0.05) {
                        player1.health -= 8;
                        playHitSound();
                    }
                }
                
                // Player attack
                if (keys['KeyG'] && Math.abs(player1.x - cpu.x) < 100) {
                    cpu.health -= 10;
                    keys['KeyG'] = false; // Prevent spam
                    playPunchSound();
                }
                
                drawFighter(player1);
                drawFighter(cpu);
                
                // Check victory
                if (player1.health <= 0) {
                    gameRunning = false;
                    alert('üíÄ DEFEAT! CPU Wins!\\nPress OK to restart or go back to hub.');
                    restartFighter();
                } else if (cpu.health <= 0) {
                    gameRunning = false;
                    alert('üèÜ VICTORY! You Win!\\nPress OK to restart or go back to hub.');
                    restartFighter();
                }
                
                if (gameRunning && currentGame === 'fighter') {
                    requestAnimationFrame(gameLoop);
                }
            }
            
            function restartFighter() {
                player1.health = 100;
                cpu.health = 100;
                player1.x = 150;
                cpu.x = 750;
                gameRunning = true;
                gameLoop();
            }
            
            // Event listeners
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
            });
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            
            gameLoop();
        }
        
        // Helicopter Game
        function initHelicopterGame() {
            const canvas = document.getElementById('helicopterCanvas');
            const ctx = canvas.getContext('2d');
            
            let helicopter = { x: 80, y: 250, health: 100 };
            let enemies = [];
            let projectiles = [];
            let score = 0;
            let coins = 0;
            let keys = {};
            let gameRunning = true;
            
            function spawnEnemy() {
                if (Math.random() < 0.02) {
                    enemies.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - 150) + 50,
                        health: 25,
                        speed: 2 + Math.random() * 4,
                        type: Math.random() < 0.5 ? 'fighter' : 'bomber'
                    });
                }
            }
            
            function gameLoop() {
                if (!gameRunning) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Sky background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87ceeb');
                gradient.addColorStop(1, '#4682b4');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Handle input
                if (keys['KeyW'] && helicopter.y > 10) helicopter.y -= 5;
                if (keys['KeyS'] && helicopter.y < canvas.height - 60) helicopter.y += 5;
                if (keys['KeyA'] && helicopter.x > 10) helicopter.x -= 5;
                if (keys['KeyD'] && helicopter.x < canvas.width - 100) helicopter.x += 5;
                
                // Draw helicopter
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(helicopter.x, helicopter.y, 80, 40);
                ctx.fillStyle = '#333';
                ctx.fillRect(helicopter.x + 10, helicopter.y + 5, 60, 30);
                
                // Update and draw enemies
                enemies.forEach((enemy, index) => {
                    enemy.x -= enemy.speed;
                    
                    ctx.fillStyle = enemy.type === 'fighter' ? '#ff4444' : '#ff8800';
                    ctx.fillRect(enemy.x, enemy.y, 60, 30);
                    
                    if (enemy.x < -70) {
                        enemies.splice(index, 1);
                    }
                    
                    // Check collision with helicopter
                    if (checkCollision(helicopter.x, helicopter.y, 80, 40, enemy.x, enemy.y, 60, 30)) {
                        helicopter.health -= 20;
                        enemies.splice(index, 1);
                        playExplosionSound();
                    }
                });
                
                // Update and draw projectiles
                projectiles.forEach((proj, index) => {
                    proj.x += 8;
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (proj.x > canvas.width) {
                        projectiles.splice(index, 1);
                    }
                    
                    // Check collision with enemies
                    enemies.forEach((enemy, enemyIndex) => {
                        if (checkCollision(proj.x - 5, proj.y - 5, 10, 10, enemy.x, enemy.y, 60, 30)) {
                            enemies.splice(enemyIndex, 1);
                            projectiles.splice(index, 1);
                            score += 100;
                            coins += 10;
                            playExplosionSound();
                        }
                    });
                });
                
                spawnEnemy();
                
                // HUD
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('Score: ' + score, 20, 40);
                ctx.fillText('Coins: ü™ô ' + coins, 20, 70);
                ctx.fillText('Health: ' + helicopter.health + '%', 20, 100);
                
                // Health bar
                ctx.fillStyle = '#333';
                ctx.fillRect(20, 110, 200, 15);
                ctx.fillStyle = helicopter.health > 60 ? '#4caf50' : helicopter.health > 30 ? '#ff9800' : '#f44336';
                ctx.fillRect(20, 110, (helicopter.health / 100) * 200, 15);
                
                if (helicopter.health <= 0) {
                    gameRunning = false;
                    alert('üí• MISSION FAILED!\\nFinal Score: ' + score + '\\nCoins Earned: ' + coins + '\\n\\nPress OK to restart!');
                    restartHelicopter();
                }
                
                if (gameRunning && currentGame === 'helicopter') {
                    requestAnimationFrame(gameLoop);
                }
            }
            
            function restartHelicopter() {
                helicopter = { x: 80, y: 250, health: 100 };
                enemies = [];
                projectiles = [];
                score = 0;
                coins = 0;
                gameRunning = true;
                gameLoop();
            }
            
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'Space') {
                    projectiles.push({ x: helicopter.x + 80, y: helicopter.y + 20 });
                    playFireSound();
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            
            gameLoop();
        }
        
        // Art Studio
        function initArtStudio() {
            const canvas = document.getElementById('artCanvas');
            const ctx = canvas.getContext('2d');
            
            // White background
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);
        }
        
        function startDrawing(e) {
            isDrawing = true;
            const pos = getPosition(e);
            lastPosition = pos;
            draw(e);
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const canvas = document.getElementById('artCanvas');
            const ctx = canvas.getContext('2d');
            const pos = getPosition(e);
            
            ctx.lineWidth = currentTool === 'brush' ? 8 : currentTool === 'pencil' ? 3 : 15;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
            }
            
            ctx.beginPath();
            ctx.moveTo(lastPosition.x, lastPosition.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            
            lastPosition = pos;
        }
        
        function stopDrawing() {
            isDrawing = false;
        }
        
        function getPosition(e) {
            const canvas = document.getElementById('artCanvas');
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }
        
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(
                e.type === 'touchstart' ? 'mousedown' : 
                e.type === 'touchmove' ? 'mousemove' : 'mouseup', 
                {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }
            );
            e.target.dispatchEvent(mouseEvent);
        }
        
        function selectTool(tool, element) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            element.classList.add('active');
        }
        
        function clearArt() {
            const canvas = document.getElementById('artCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function downloadArt() {
            const canvas = document.getElementById('artCanvas');
            const link = document.createElement('a');
            link.download = 'MyArtwork_¬©2025_JustinDevonMitchell.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            alert('üé® Artwork downloaded as PNG!\\nCheck your Downloads folder.');
        }
        
        function downloadMovementPDF() {
            alert('üé® Creating Movement PDF...\\n\\nThis feature creates 8 frames of your artwork with movement effects!\\n\\nPrint the frames, cut them out, and flip like a book to see animation!\\n\\nFeature will download your current artwork.');
            downloadArt();
        }
        
        // Music Studio
        async function toggleRecording() {
            const button = document.getElementById('recordButton');
            
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        recordedBlob = new Blob(chunks, { type: 'audio/wav' });
                        button.textContent = 'üé§ START RECORDING';
                        button.classList.remove('recording');
                        alert('üé§ Recording complete!\\nClick "Play Recording" to hear with auto-tune effects.');
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    button.textContent = '‚èπÔ∏è STOP RECORDING';
                    button.classList.add('recording');
                    playRecordingStartSound();
                    
                } catch (error) {
                    alert('üé§ Microphone Access Required\\n\\nPlease allow microphone access to record audio.\\nClick the microphone icon in your browser and allow access.');
                }
            } else {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                isRecording = false;
                playRecordingStopSound();
            }
        }
        
        function playRecording() {
            if (recordedBlob) {
                const autoTuneLevel = document.getElementById('autoTuneSlider').value;
                const audio = new Audio(URL.createObjectURL(recordedBlob));
                
                // Apply auto-tune effect (pitch shift)
                const pitchShift = 1 + (autoTuneLevel - 50) / 200;
                audio.playbackRate = pitchShift;
                audio.volume = 0.8;
                
                audio.play().then(() => {
                    alert('üéµ Playing your recording with ' + autoTuneLevel + '% auto-tune effect!');
                }).catch(() => {
                    alert('üéµ Recording played with auto-tune effect!');
                });
            } else {
                alert('üé§ No recording available.\\nPlease record something first!');
            }
        }
        
        function downloadRecording() {
            if (recordedBlob) {
                const autoTuneLevel = document.getElementById('autoTuneSlider').value;
                const url = URL.createObjectURL(recordedBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'MyRecording_AutoTune' + autoTuneLevel + '%_¬©2025_JustinDevonMitchell.wav';
                link.click();
                alert('üé§ Recording downloaded!\\nFilename: MyRecording_AutoTune' + autoTuneLevel + '%_¬©2025_JustinDevonMitchell.wav\\n\\nCheck your Downloads folder!');
            } else {
                alert('üé§ No recording to download.\\nPlease record something first!');
            }
        }
        
        function updateAutoTuneDisplay() {
            const value = document.getElementById('autoTuneSlider').value;
            document.getElementById('autoTuneDisplay').textContent = value + '% Auto-tune';
        }
        
        function playBeat(beatType) {
            initAudio();
            if (!audioContext) return;
            
            if (beatInterval) {
                clearInterval(beatInterval);
                beatInterval = null;
                alert('ü•Å Beat stopped.');
                return;
            }
            
            const beats = {
                'hip-hop': { bpm: 90, pattern: [1, 0, 1, 0, 1, 0, 1, 0] },
                'rock': { bpm: 120, pattern: [1, 1, 0, 1, 1, 1, 0, 1] },
                'electronic': { bpm: 128, pattern: [1, 0, 0, 1, 1, 0, 0, 1] },
                'trap': { bpm: 140, pattern: [1, 0, 1, 0, 0, 1, 0, 1] }
            };
            
            const beat = beats[beatType];
            const interval = (60000 / beat.bpm) / 2;
            let index = 0;
            
            beatInterval = setInterval(() => {
                if (beat.pattern[index]) {
                    playDrumSound();
                }
                index = (index + 1) % beat.pattern.length;
            }, interval);
            
            alert('ü•Å Playing ' + beatType + ' beat!\\nClick same button again to stop.\\nRecord your voice over the beat!');
        }
        
        // Sound Functions
        function playPunchSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(200, audioContext.currentTime);
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.15);
        }
        
        function playHitSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(800, audioContext.currentTime);
            gain.gain.setValueAtTime(0.25, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.12);
        }
        
        function playFireSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, audioContext.currentTime);
            gain.gain.setValueAtTime(0.2, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.2);
        }
        
        function playExplosionSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, audioContext.currentTime);
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
        }
        
        function playRecordingStartSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, audioContext.currentTime);
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.1);
        }
        
        function playRecordingStopSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, audioContext.currentTime);
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.2);
        }
        
        function playDrumSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(60, audioContext.currentTime);
            gain.gain.setValueAtTime(0.2, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 0.2);
        }
        
        // Utility function
        function checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
        }
        
        // Welcome message
        setTimeout(() => {
            alert('üéÆ ¬© 2025 JUSTIN DEVON MITCHELL\\nFIGHTER SHOOTER ART GAME\\n\\n‚úÖ COMPLETE OFFLINE VERSION\\n\\nThis game works completely offline!\\n\\nFeatures:\\nü•ä Fighter Legends - Boxing with legendary characters\\nüöÅ Helicopter Combat - Enemy aircraft shooter\\nüé® Art Studio - Professional drawing tools\\nüé§ Music Studio - Recording with auto-tune\\n\\nüì± Mobile compatible - Works on phones!\\nüíæ All downloads work offline!\\n\\nNo internet required after download!');
        }, 2000);
    </script>
</body>
</html>`;

      // Download the complete offline game
      const blob = new Blob([gameHTML], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'JustinDevonMitchell-COMPLETE-OFFLINE-GAME.html';
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      // Success notification
      setTimeout(() => {
        alert(`üíæ COMPLETE OFFLINE GAME DOWNLOADED!

¬© 2025 JUSTIN DEVON MITCHELL FIGHTER SHOOTER ART GAME

‚úÖ Downloaded: JustinDevonMitchell-COMPLETE-OFFLINE-GAME.html

OFFLINE FEATURES:
ü•ä Fighter Legends - Full boxing game
üöÅ Helicopter Combat - Complete shooter  
üé® Art Studio - Drawing + downloads
üé§ Music Studio - Recording + auto-tune

WORKS COMPLETELY OFFLINE:
‚úÖ No internet needed
‚úÖ All games fully playable
‚úÖ Recording and art creation
‚úÖ Mobile compatible

TO PLAY:
1. Find file in Downloads folder
2. Double-click to open
3. Play all 4 games offline!

TO CREATE PERMANENT LINK:
üì§ Upload file to netlify.com
üîó Get forever shareable link

Check Downloads folder now!`);
      }, 2000);

    } catch (error) {
      alert('Download failed. Please allow downloads in your browser settings.');
    }
  };
>>>>>>> REPLACE